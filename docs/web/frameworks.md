# Библиотеки и фреймворки

Прежде чем рассмотреть самые ходовые библиотеки и фреймворки на питоне, нужно понять, что такое библиотека и фреймворк.

Отлие имеется и ровно одно, фреймворк задаёт процесс разработки, в то время как библиотека лишь просто инструмент который можно где-то в коде вызвать и забыть. Пример того что заставляет писать в определённом стиле это django на питоне, и react на js. А пример библиотеки это numpy, math, datetime и т.д.

## Вэб

### Django

Когда люди слышат про вэб на питоне, первое что они вспоминают это django. Фреймворк который прямо диктует свою архитектуру от которой нет способа отойти. Он что что называется "всё включено", в комплекте и работа с бд с их собственной orm(в будущем будет статья про это, тогда заменю это на ссылку), логироание, авторизация, созданием html страниц через встроенный [движок шаблонизатор](https://habr.com/ru/companies/vk/articles/698532/), админка и т.д.

Он очень хорош для быстрого прототипирования, но если вам нужно что-то нестандартное, то вам придётся писать костыли, ибо он не предполагает никаких изменений в своей архитектуре. Пример - подключение mongodb, есть корявый гайд на сайте монги, либо куча ещё кривых гайдов хабре.

В целом если вы фуллстек разработчик и хотите очень быстрый набор большинства инструментов из коробки одной строчкой кода, при этом сайт не будет иметь большцую нагрузку - отличный выбор. С выпуска в 2005 году и 77к звёздочек на гитхабе разработчики успели учесть практически все типовые ситуации.

### FastAPI

FastAPI - это современный, быстрый (высокопроизводительный) веб-фреймворк для создания API на Python, основанный на стандартных тайпхинтах(это когда наводишься на функцию, а там написан не просто требуемый аргумент, а через двоеточние от него тип, напрмиер 
```def func(a: int) -> int```) Python. (взял с его же сайта)

Именно на этом фреймворке я пишу все свои вэбпроекты.

Его очень жирный плюс и одновременно огромный минус заключается в абсолютной свободе которая позволяет тебе использовать абсолютно любую архитектуру, но в то же время не даёт никаких подсказок как это делать. Примеры архитектур: луковая архитектура, mvc(не путать с mvvc которая онли для мобильных приложений), DDD и т.д.(позже примеры и гайды по архитектурам будут добавлены на сайт).

Второй плюс это абсолютная совместимость с любой библиотекой: sqlalchemy, tenserflow, pymongo(на django не работает), и т.д.

Третий плюс, это полная [асинхронность](./async.md). Данный пункт является крайне важным т.к. позволяет делать очень быстрые приложения которые завязаны на ввод-вывод([IO-bound](./parallel.md/#cpu-bound-io-bound)).

Стоит так же упомянуть, что крутая особенность django - движки шаблонизаторы - не является его киллерфичей, их можно использовать и в fastapi, для этого гуглить **jinja2template** fastapi.

Ещё одним плюсом является автогенерируемый [swagger](https://practicum.yandex.ru/blog/chto-takoe-swagger/)(обычно его писать крайне неприятно).

Стоит так же вспомнить абсолютную интеграцию pydantic(библиотека для валидации данных) и fastapi, что позволяет писать крайне чистый код. То есть присланные данные вы не проверяете через кучу if else или match, а просто создаёте модель(pydantic model), прописываете в неё поля данных и их типы и так же можно кучу наворотов накинуть по типу првоерки длины строки, диапазона числа, да хоть собственный валидатор можно написать, там это делается крайне удобно, а потом в функцию пишете ```async def route(data: model)``` и данные сами провалидировались и если что не так вернулась 422 клиенту.

Данный фреймворк существует меньше чем django(2018 год выпуска), но уже успел набрать популярность(71к звёздочек на гитхабе), и его используют такие компании как microsoft, netflix, uber и т.д. в своих проектах. Так же крайне популярный выбор в стартапах которые закладывают рост популярности изначально(хотя в таких случаях я бы выбрал гошку а не питон, даже чистый старлетт).

Если нужен очень быстрый API(всё же рендер html через него крайне не популярная задача) под любые задачи - это ваш выбор.

### Flask

Flask ещё недавно был(2010 год создания) одним из самых популярных веб-фреймворков на питоне(66к звёздочек на гитхабе), но с выходом fastapi он стал уходить в тень. Он является более лёгким и простым в использовании, но при этом не таким быстрым как fastapi. Он так же как и fastapi позволяет использовать любую архитектуру, но при этом не так хорошо поддерживает асинхронность(при это есть фреймворк [quart](https://quart.palletsprojects.com), полностью асинхронная версия flask но всего 3к звёздочек как-то смущают). 

Он является чем-то средним, на нём больше сторонних решений по типу авторизаций, работы с бд адаптированных именно для фласка и т.д. Книг по нему тоже ультра много.

Его функционал достаточно универсален. Его роутинг(способ задать путь до функции с сайта)
точно такой же как в fastapi, ведь именно им и вдохновлялся создатель последнего. При этом его очень часто используют для отрисовки части html прямо на сервере(то есть функции возвращают куски html кода, буквально ```return f"<div> {data} </div>"```).

Стоит упомянуть что практичеаки весь сайт ВШЭ сделан либо на php, либо на flask.

В целом позор общества а не фреймворк, по моему личному мнению не достоин внимания вовсе.

### Aiogram

Это фреймворк для написания тг ботов, у него есть аналоги - pyrogram(единственное применение юзерботы, это когда бот управляет не бот аккаунтом, а реальным аккаунтом, то есть может и первый писать, и добавляться куда-то сам и т.д.), python-telegram-bot и telebot(остальные уже вообще позорище конкретное). Но круче аиограмма нет ничего.

Он наследует идеологию flask а позже и fastapi с роутами через декораторы. Полностью асинхронный, имеет встроенный способ подключения к серверам тг через webhook а не лонгпулинг. 

Говорить про него больше нечего, конкурентов в поприще тг ботов у него нет.

Кстати самый лучший гайд по нему вот:

https://mastergroosha.github.io/

Если вы патриот РФ в их чат вам лучше не лезть, даже в _ru чате сидят толпы идиотов которые даже зная русский язык(даже в био у них русский текст) будут отвечать вам на своём бреде.


## Работа с базами данных

### SQLAlchemy

SQLAlchemy - монстр среди ORM(подход при котором вы работаете с данными не как фигнёй а как с объектами питона) библиотек для sql баз данных. Он позволяет вам писать запросы на sql на питоне, что позволяет вам писать крайне чистый код. Он так же позволяет вам использовать любую базу данных, асинхронность с недавних версий завезли из коробки.

Ему доступны PostgreSQL, SQLite, MySQL, Oracle, Microsoft SQL Server, Firebird, Sybase и даже куча экзотических баз данных. При этом данная либане является фаворитом при работе с nosql базами данных.

Отличие работы с бд через SQLAlchemy и сырой драйвер:
```py
# Сырой драйвер
import psycopg2

conn = psycopg2.connect("dbname=test user=postgres")
cur = conn.cursor()
cur.execute("SELECT * FROM test")
rows = cur.fetchall()
print(rows)

# SQLAlchemy
from sqlalchemy import create_engine, MetaData, Table

engine = create_engine('postgresql://postgres@localhost/test')
meta = MetaData()
table = Table('test', meta, autoload_with=engine)
print(table.select().execute().fetchall())
```

Может покзааться что код не так уж и короче, но вся соль кроется в строке table, ведь благодаря ней мы можем писать запросы без знания sql, а просто методы питона, при этом ещё и абсолютная защита от sql инъекций(наверное). Вот пример такого кода:
```py
from sqlalchemy import select

print(table.select().where(table.c.id == 1).execute().fetchall())
print(select([table]).where(table.c.id == 1).execute().fetchall())
```

Единственный минус это то, что прежде чем отправить запрос в бд его придётся всё же приобразовать в сырой запрос, но при огромных вычислениях это будет уже не так сильно влиять.

### Redis

Redis - это крайне быстрая база данных, которая хранит данные в оперативной памяти. Она используется для кеширования, хранения сессий, очередей задач и т.д. Она имеет крайне простой интерфейс, но при этом кучу возможностей. Она так же имеет асинхронный драйвер, что позволяет использовать её в асинхронных приложениях.

Пример использования:
```py
import asyncio
from redis.asyncio import Redis

async def main():
    redis = Redis()
    await redis.set('my-key', 'value')
    value = await redis.get('my-key')
    print(value)

asyncio.run(main())
```

Как видим синтаксис крайне простой, просто 2 функции set и get для подовляющего большинства задач. Конечно там есть и [pub/sub](https://redis-py.readthedocs.io/en/stable/advanced_features.html#publish-subscribe) но он мне пригодился лишь единожды(для базы данных обратных отсчётов, пока я не научился пользоваться rabbit mq).

Конечно сейчас происходят какие-то тёрки в сообществе redis из-за их возможного перехода на платные рельсы, и microsoft уже подсуетились, сделав [garnet](https://github.com/microsoft/garnet) подключение к которму доступно через всё то же самое, что даёт доступ к обычному redis, это как с пиратскими серверами по вов, клиент 1, а сервер любой.(если кто напомнит, попробую углубиться в тему, чё там с редисом происходит).

### Pymongo / motor

MongoDB - моя первая дб, и я до сих пор её люблю. Она крайне проста в использовании, но при этом имеет кучу возможностей. Она хранит данные в формате документов(json) в отличае от строк в sql, что позволяет вам хранить кучу разных данных в одной коллекции(аналог таблиц в sql). Базы данных там называются так же.

Ключевая фишка mongodb - отсутствие строгой схемы данных, то есть у вас в одной коллекции могут лежать рядом документы ```{"a": 1}``` и ```{"b": "КТО ПРОЧИТАЛ ТОТ СДОХНЕТ"}```.

Pymongo - это драйвер для работы с mongodb на питоне, он позволяет вам отправлять сразу dict в базу, и получать их же по запросу. Motor - полностью асинхронная версия наследующая код pymongo.

Для задач неструктурированных данных бд лучше не придумать. Кстати часто используется в играх.

Прример:
```py
import asyncio
import motor

client = motor.motor_asyncio.AsyncIOMotorClient('mongodb://localhost:27017')
db = client['database']
collection = db['collection']

async def func():
    await collection.insert_one({"a": 1})
    print(await collection.find_one({"a": 1}))

asyncio.run(func())
```


## Продолжение следует
если кто-то попросит, сделаю и на другие либы разбор, у меня их много накопилось, это основные