# Управление зависимостяи и виртуальным окружением

Большие проекты часто зависят от других внешних библиотек не идущих в комплекте с питоном. Для их установки и использования созданы такие технологии как как пакетный менеджер pip и менеджер виртуальных окружений venv.

## Управление зависимостями через pip

Pip - это пакетный менеджер для питона. Он позволяет установить пакеты из сети и управлять ими.
Синтаксис работы с ним крайне простой

```sh
pip <command> [param1, param2, ...]
```
Здесь:
1. pip это команда через которую происходит работа с менеджером пакетов, 
2. command - команда, например install, uninstall, freeze и т.д.
3. params - параметры команды, например имя пакета, версия и т.д.


### Установка пакетов

> Не забывайте, что пакеты должны быть установлены в виртуальное окружение. Поэтому перед установкой пакета убедитесь, что в виртуальном окружении. Про него - далее.

```
pip install numpy
```

Установит пакет numpy с его собственными зависимостями.

```
pip install numpy==1.25.0
```

Установит пакет numpy строго версии 1.25.0

```
pip install numpy pandas matplotlib
```

Данная версия установит джентельменский набор уважающего себя датасайнтиста у которого стынет латте на кокосовом молоке с корицей и оливковым маслом.

### Удаление пакета

```
pip uninstall numpy
pip uninstall numpy pandas matplotlib
```

Данные команды удаляют 1 или несколько пакетов сразу.

### Просмотр установленных пакетов

Чтобы посмотреть установленные сейчас пакеты есть 3 способа, человеческий, деловой(в [rfc](https://datatracker.ietf.org/doc/html/rfc5322) формате и только определённого пакета) и для разработчиков.

Человеческий:

```sh
pip list
```

Вывод данной команды будет выглядеть так:

```
Package           Version
----------------- -------
fuzzywuzzy        0.18.0
gitdb             4.0.11
GitPython         3.1.42
pip               23.1.2
py-cpuinfo        9.0.0
python-dotenv     1.0.1
pytz              2024.1
setuptools        65.5.0
six               1.16.0
smmap             5.0.1
sniffio           1.3.1
typing_extensions 4.10.0
tzdata            2024.1
uritemplate       4.1.1
urllib3           2.2.1
uv                0.1.10
wheel             0.43.0
```

Для очень оффициального вида:

```sh
pip show urllib3 # библиотека на которой работает этот сайт
```

Её вывод выглядит так:
```
Name: urllib3
Version: 2.2.1
Summary: HTTP library with thread-safe connection pooling, file post, and more.
Home-page:
Author:
Author-email: Andrey Petrov <andrey.petrov@shazow.net>
License:
Location: C:\Python311\Lib\site-packages
Requires:
Required-by:
```

И наконец-то последняя команда, которая является самой частой, именно её вы будете писать чаще всего для проверки версий библиотек:

```
pip freeze
```

Но такой варант выведет всё в терминал, а если вы хотите получить вывод в виде файла, то можно использовать следующую конструкцию

```
pip freeze > requirements.txt
```

Вместо requirements.txt можно использовать любое другое имя файла но такое название является общепринятым. Кстати, зайдя в любой репозиторий на гитхабе для питон проектов вы точно найдёте там этот файл, тогда можно сразу посмотреть использумые проектом библиотеки.

Данный файл является очень важным для всех кто 

### Установка зависимостей

Когда вы скачиваете чужой проект или свой с гитхаба/откуда-то ещё, вам не нужно заново писать много раз pip install с названимями всех библиотек.

Достаточно написать:

```
pip install -r requirements.txt
```

Название ```requirements.txt``` является общепринятым, некоторые(я) сокращают это до просто ```r.txt``` но это уже на ваше усмотрение.

## Управление виртуальным окружением через venv

Venv - модуль питона отвечающий за создание и управление виртуальными окружениями. Виртуальное окружение - это изолированное пространство в котором установлены только те библиотеки которые нужны для работы вашего проекта. Это позволяет избежать конфликтов зависимостей.

Пример конфликта зависимостей: у вас есть проект который использует библиотеку ```aiogram 2```, а другой проект использует ```aiogram``` версии ```3```. Если вы установите обе версии в глобальное окружение, то при импорте ```aiogram``` в одном из проектов будет использоваться не та версия библиотеки что приведёт к глобальной поломке системы из-за очень разного стиля работы с библиотекой.

### Создание виртуального окружения

Для создания виртуального окружения используется команда:

```
python -m venv venv
```

Здесь ```python -m``` - это способ запуска какого либо модуля, первый ```venv``` - это модуль для создания виртуальных окружений, а последний ```venv``` - это имя папки в которой будет создано виртуальное окружение.

Папку с виртуальным окржукением можно назвать как угодно, но общепринятым является ```env``` и ```venv``` (я использую этот вариант и далее будут примеры с ним).

### Активация виртуального окружения

Для активации виртуального окружения используется команда:


=== "Linux/MacOS"

    ```
    source venv/bin/activate
    ```

=== "Windows"

    ```
    .\venv\Scripts\activate
    ```

Здесь во всех системах вместо ```venv``` нужно писать то название виртуального окружения которое вы использовали при создании.

После активации виртуального окружения в терминале появится префикс с названием папки виртуального окружения ```(venv)```:

```
C:\python_project> .\venv\Scripts\activate
(venv) PS C:\python_project>
```

### Управление зависимостями в виртуальном окружении

После активации виртуального окружения все установленные пакеты будут устанавливаться только в него. Также все установленные пакеты будут доступны только в этом окружении. В синтакисе команд pip ничего не меняется, все команды работают также как и в глобальном окружении. Получение всех зависимостей виртуального окружения тут играет на полную катушку, потому что теперь мы можем [получить требуемые пакеты именно для этого приложения](#_4) и [установить их именно для него](#_5) команад.

## Виртуальное окружение через uv

> Данный раздел является дополнительным и не является обязательным для изучения.

[uv](https://github.com/astral-sh/uv) - пакет позволяющий крайне удобно и быстро работать с виртуальным окружением(по моим тестам в среднем в 30+ раз быстрее).

[Способов установить его много](https://github.com/astral-sh/uv?tab=readme-ov-file#getting-started), лично я использую вариант через powershell.

```powershell
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"
```

Работа с ним не очень сильно отличается от обычного venv.

### Созданием и активация виртуального окружения через uv

```sh
uv venv venv
```

Тут по аналогии с обычными виртуальным окружением, первый ```venv``` - это модуль для создания виртуальных окружений, а последний ```venv``` - это имя папки в которой будет создано виртуальное окружение. Единственное отличие что в начале нужно добавить слово ```uv```.

Выбрана будет дефолтная глобальная версия() питона, но можно указать конкретную версию:

```
uv venv --python python3.10
```

Данный способ работает криво и вообще не понятно как, у меня он на линуксе заработал, а винда отчаяно игнорирует. Но [разработчики лично мне рекомендвали именно этот способ](https://github.com/astral-sh/uv/issues/2222).

Активация обычная:

=== "Linux/MacOS"

    ```
    source venv/bin/activate
    ```

=== "Windows"

    ```
    .\venv\Scripts\activate
    ```

### Установка пакетов и фишки uv

```sh
uv pip install fastapi
```

Для установки пачки зависимостей

```sh
uv pip install -r r.txt
```
либо
```sh
uv pip sync r.txt
```
!!! Осторожно

    Нужно понимать что здесь имеется разница, при инсталле у вас левые либы не стираются которые вы установили просто через пип а не через файл, а при синке всё что не указано в файле удаляется, но оно и правильно.

Пакет uv так же поглотил в себя pip-tools и ему подобные, из-за чего мы имеем возможность "компилировать зависимости". В таком случае конфликт зависимостей будет решён за вас.

Есть файлы с расширением ```.in```, в них удобно писать просто названия нужных либ даже без версий(но если очень нужно, то версию можно зафиксировать), а потом с помощью следующей команды получить стандартный r.txt файлик к которому мы так привыкли:

```sh
uv pip compile r.in -o r.txt
```

Всё вроме r.in и r.txt нужно запомнить наизусть, первый файл это входной, второй файл это выходной.

### Пример компиляции

```r.in```:
```
fastapi
sqlalchemy
```

```r.txt```: (файл огромный, я сократил троеточием)
```
# This file was autogenerated by uv via the following command:
#    uv pip compile r.in -o r.txt

...
fastapi==0.111.0
    # via fastapi-cli
fastapi-cli==0.0.2
    # via fastapi
...

sqlalchemy==2.0.29
starlette==0.37.2
    # via fastapi
typer==0.12.3
...
```
